#   Copyright (C) 2016-2018  Povilas Kanapickas <povilas@radix.lt>
#
#   This file is part of libsimdpp asm tests
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see http://www.gnu.org/licenses/.

import itertools
from collections import OrderedDict


def flatten_list(arg):
    ret = []
    for a in arg:
        if isinstance(a, list):
            ret += flatten_list(a)
        else:
            ret.append(a)
    return ret

def force_flat_list(arg):
    if not isinstance(arg, list):
        return [arg]
    return flatten_list(arg)

class CodeCombinator:
    ''' Represents a set of code snippets generated from a template and
        substitutions within it. For each possible substitution position user
        supplies a list of strings to substitute. The generated set of code
        snippets includes all combinations of possible substitutions for each
        position. The template is format-compatible string.
    '''

    def __init__(self, template, a1=None, a2=None, a3=None, a4=None):
        self.template = template
        self.a1 = a1
        self.a2 = a2
        self.a3 = a3
        self.a4 = a4

    def generate(self):
        ''' Generates tuples each containing formatted template and a
            potentially empty list of arguments used to format the template.
        '''
        if self.a1 == None:
            yield [(self.template, [])]
        elif self.a2 == None:
            for q1 in self.a1:
                yield (self.template.format(q1), [q1])
        elif self.a3 == None:
            for (q1,q2) in itertools.product(self.a1, self.a2):
                yield (self.template.format(q1, q2), [q1, q2])
        elif self.a4 == None:
            for (q1,q2,q3) in itertools.product(self.a1, self.a2, self.a3):
                yield (self.template.format(q1, q2, q3), [q1, q2, q3])
        else:
            for (q1,q2,q3,q4) in itertools.product(self.a1, self.a2, self.a3, self.a4):
                yield (self.template.format(q1, q2, q3, q4), [q1, q2, q3, q4])

class CodeGenerator:
    ''' Represents a set of code snippets generated from a template and
        substitutions within it generated by a given generator. Each invocation
        of the generator should return a list of strings identifying the
        substitutions for particular code snippet. The template is
        format-compatible string.
    '''
    def __init__(self, template, function):
        self.template = template
        self.function = function

    def generate(self):
        for args in self.function():
            yield (self.template.format(args), args)

class TestGenerator:
    ''' Represents parameters defining a set of tests to run. Each parameter
        may have several values defined. The test list is generated by
        selecting all possible combinations of parameters.

        The bytes and types parameters may contain list of lists which will be
        flattened.
    '''
    def __init__(self, snippets, bytes, types):
        self.snippets = snippets
        self.bytes = force_flat_list(bytes)
        self.types = force_flat_list(types)

    def generate_snippets(self):
        if (isinstance(self.snippets, CodeGenerator) or
            isinstance(self.snippets, CodeCombinator)):
            for snip, args in self.snippets.generate():
                yield snip
        elif isinstance(self.snippets, list):
            for snip in self.snippets:
                yield snip
        else:
            yield self.snippets

    def generate(self):
        for snippet in self.generate_snippets():
            for types in self.types:
                for bytes in self.bytes:
                    yield TestDesc(snippet, bytes, types)

class TestDesc:
    ''' Contains description of a single test'''
    def __init__(self, code, bytes, types):
        self.code = code
        self.bytes = bytes
        self.rtype = types[0] if len(types) > 0 else None
        self.atype = types[1] if len(types) > 1 else None
        self.btype = types[2] if len(types) > 2 else None
        self.ctype = types[3] if len(types) > 3 else None

    @staticmethod
    def from_json(json_data):
        code = json_data['code']
        bytes = json_data['bytes']
        types = list(json_data['types'])
        return TestDesc(code, bytes, types)

class Test:
    def __init__(self, desc, ident):
        self.desc = desc
        self.ident = ident
        self.insns = None

    def to_json(self):
        ret = {
            'code' : self.desc.code,
            'bytes' : self.desc.bytes,
        }
        if self.insns is not None:
            sorted_insns = sorted(self.insns.insns.items(), key=lambda x: x[0])
            ret['zinsns'] = { insn : count for (insn, count) in sorted_insns
                              if count != 0 },
        else:
            ret['success'] = False

        if self.desc.rtype != None:
            ret['vr'] = self.desc.rtype
        if self.desc.atype != None:
            ret['va'] = self.desc.atype
        if self.desc.btype != None:
            ret['vb'] = self.desc.btype
        if self.desc.ctype != None:
            ret['vc'] = self.desc.ctype
        return ret

def group_tests_by_code(tests):
    groups = OrderedDict()

    for test in tests:
        code = test.desc.code
        if code in groups:
            groups[code].append(test)
        else:
            groups[code] = [ test ]

    return groups.values()

class TestOutput:
    def __init__(self):
        self.code = []
        self.templates = None
        self.insn_set = []
        self.bytes = None
        self.rtypes = []
        self.atypes = []
        self.btypes = []
        self.ctypes = []
        self.insns = None

    def fill_data(self, test, insn_set):
        self.code = test.desc.code
        self.templates = test.desc
